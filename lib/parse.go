package lib

import (
	"encoding/json"
	"fmt"
	"sort"
)

// BufferToMessage takes in a message buffer and returns a message string.
func BufferToMessage(buf []byte) (string, error) {
	var msg string
	var parsed interface{}
	if err := json.Unmarshal(buf, &parsed); err != nil {
		log.WithError(err).Error("decoding json error")
		return "", fmt.Errorf("decoding json to structured data: %w", err)
	}

	switch parsed.(type) {
	case Sonarr:
		data := parsed.(Sonarr)
		for _, ep := range data.Episodes {
			msg += fmt.Sprintf("Sonarr: %s %dx%02d - %q\n", data.Series.Title, ep.SeasonNumber, ep.EpisodeNumber, *data.EventType)
		}
	case Lidarr:
		data := parsed.(Lidarr)
		for _, ep := range data.Albums {
			msg += fmt.Sprintf("Lidarr: %s - %q - %s\n", data.Artist.Name, ep.Title, *data.EventType)
		}
	case GoogleCloud:
		data := parsed.(GoogleCloud)
		msg += fmt.Sprintf("GCP Alert - %q\n", data.Incident.Summary)
	case Plex:
		data := parsed.(Plex)
		msg += fmt.Sprintf("Plex - %q : %s %dx%d\n", data.Event, data.Metadata.GrandparentTitle, data.Metadata.ParentIndex, data.Metadata.Index)
	case map[string]string:
		f := parsed.(map[string]string)

		var keys []string
		for k := range f {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			msg += fmt.Sprintf("%s: %s\n", k, f[k])
		}
	default:
		return "", fmt.Errorf("don't know how to parse")
	}

	return msg, nil
}

// Sonarr is the structure of messages we get from Sonarr.
//
// Generated by https://mholt.github.io/json-to-go/
type Sonarr struct {
	Episodes []struct {
		ID             int    `json:"id"`
		EpisodeNumber  int    `json:"episodeNumber"`
		SeasonNumber   int    `json:"seasonNumber"`
		Title          string `json:"title"`
		QualityVersion int    `json:"qualityVersion"`
	} `json:"episodes"`
	EventType *string `json:"eventType"`
	Series    struct {
		ID     int    `json:"id"`
		Title  string `json:"title"`
		Path   string `json:"path"`
		TvdbID int    `json:"tvdbId"`
	} `json:"series"`
}

func jsonToSonarr(buf []byte) *Sonarr {
	var data Sonarr
	if err := json.Unmarshal(buf, &data); err != nil {
		log.WithError(err).Error("decoding json to Sonarr")
		return nil
	}
	log.WithField("data", data).Debug("Sonarr data decoded")

	return &data
}

// GoogleCloud is the structure of messages we get from Google Cloud Platform Alerting.
//
// Generated by https://mholt.github.io/json-to-go/
type GoogleCloud struct {
	Incident struct {
		IncidentID   string `json:"incident_id"`
		ResourceID   string `json:"resource_id"`
		ResourceName string `json:"resource_name"`
		Resource     struct {
			Type   string `json:"type"`
			Labels struct {
				Host string `json:"host"`
			} `json:"labels"`
		} `json:"resource"`
		ResourceTypeDisplayName string `json:"resource_type_display_name"`
		Metric                  struct {
			Type        string `json:"type"`
			DisplayName string `json:"displayName"`
		} `json:"metric"`
		StartedAt     int    `json:"started_at"`
		PolicyName    string `json:"policy_name"`
		ConditionName string `json:"condition_name"`
		Condition     struct {
			Name               string `json:"name"`
			DisplayName        string `json:"displayName"`
			ConditionThreshold struct {
				Filter       string `json:"filter"`
				Aggregations []struct {
					AlignmentPeriod    string   `json:"alignmentPeriod"`
					PerSeriesAligner   string   `json:"perSeriesAligner"`
					CrossSeriesReducer string   `json:"crossSeriesReducer"`
					GroupByFields      []string `json:"groupByFields"`
				} `json:"aggregations"`
				Comparison     string  `json:"comparison"`
				ThresholdValue float64 `json:"thresholdValue"`
				Duration       string  `json:"duration"`
				Trigger        struct {
					Count int `json:"count"`
				} `json:"trigger"`
			} `json:"conditionThreshold"`
		} `json:"condition"`
		URL     string      `json:"url"`
		State   string      `json:"state"`
		EndedAt interface{} `json:"ended_at"`
		Summary string      `json:"summary"`
	} `json:"incident"`
	Version string `json:"version"`
}

func jsonToGoogleCloud(buf []byte) *GoogleCloud {
	var data GoogleCloud
	if err := json.Unmarshal(buf, &data); err != nil {
		log.WithError(err).Error("decoding json to GoogleCloud")
		return nil
	}
	log.WithField("data", data).Debug("GoogleCloud data decoded")

	return &data
}

// Lidarr provides a structure for Lidarr updates.
//
// Generated by https://mholt.github.io/json-to-go/
type Lidarr struct {
	Albums []struct {
		ID             int    `json:"id"`
		Title          string `json:"title"`
		QualityVersion int    `json:"qualityVersion"`
	} `json:"albums"`
	EventType *string `json:"eventType"`
	Artist    struct {
		ID   int    `json:"id"`
		Name string `json:"name"`
		Path string `json:"path"`
		MbID string `json:"mbId"`
	} `json:"artist"`
}

func jsonToLidarr(buf []byte) *Lidarr {
	var data Lidarr
	if err := json.Unmarshal(buf, &data); err != nil {
		log.WithError(err).Error("decoding json to Lidarr")
		return nil
	}
	log.WithField("data", data).Debug("Lidarr data decoded")

	return &data
}

// Plex provides a structure for Plex updates.
//
// Generated by https://mholt.github.io/json-to-go/
type Plex struct {
	Event   string `json:"event"`
	User    bool   `json:"user"`
	Owner   bool   `json:"owner"`
	Account struct {
		ID    int    `json:"id"`
		Thumb string `json:"thumb"`
		Title string `json:"title"`
	} `json:"Account"`
	Server struct {
		Title string `json:"title"`
		UUID  string `json:"uuid"`
	} `json:"Server"`
	Player struct {
		Local         bool   `json:"local"`
		PublicAddress string `json:"publicAddress"`
		Title         string `json:"title"`
		UUID          string `json:"uuid"`
	} `json:"Player"`
	Metadata struct {
		LibrarySectionType    string  `json:"librarySectionType"`
		RatingKey             string  `json:"ratingKey"`
		Key                   string  `json:"key"`
		ParentRatingKey       string  `json:"parentRatingKey"`
		GrandparentRatingKey  string  `json:"grandparentRatingKey"`
		GUID                  string  `json:"guid"`
		ParentGUID            string  `json:"parentGuid"`
		GrandparentGUID       string  `json:"grandparentGuid"`
		Type                  string  `json:"type"`
		Title                 string  `json:"title"`
		GrandparentTitle      string  `json:"grandparentTitle"`
		ParentTitle           string  `json:"parentTitle"`
		ContentRating         string  `json:"contentRating"`
		Summary               string  `json:"summary"`
		Index                 int     `json:"index"`
		ParentIndex           int     `json:"parentIndex"`
		Rating                float64 `json:"rating"`
		ViewCount             int     `json:"viewCount"`
		LastViewedAt          int     `json:"lastViewedAt"`
		Year                  int     `json:"year"`
		Thumb                 string  `json:"thumb"`
		Art                   string  `json:"art"`
		ParentThumb           string  `json:"parentThumb"`
		GrandparentThumb      string  `json:"grandparentThumb"`
		GrandparentArt        string  `json:"grandparentArt"`
		GrandparentTheme      string  `json:"grandparentTheme"`
		OriginallyAvailableAt string  `json:"originallyAvailableAt"`
		AddedAt               int     `json:"addedAt"`
		UpdatedAt             int     `json:"updatedAt"`
	} `json:"Metadata"`
}

func jsonToPlex(buf []byte) *Plex {
	var data Plex
	if err := json.Unmarshal(buf, &data); err != nil {
		log.WithError(err).Error("decoding json to Plex")
		return nil
	}
	log.WithField("data", data).Debug("Plex data decoded")

	return &data
}
